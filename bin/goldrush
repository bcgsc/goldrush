#!/usr/bin/make -rRf
# Pipeline for the Goldrush program
# Written by Puneet Sidhu, Johnathan Wong, Lauren Coombe, and Vladimir Nikolic

# Input files
reads=reads

polisher=goldrush-edit
polished_infix=$(polisher)-polished
# ntlink or minimap2
polisher_mapper=ntlink

ifeq ($(polisher_mapper),ntlink)
goldrush_edit_opts=--ntlink
else ifeq ($(polisher_mapper),minimap2)
goldrush_edit_opts=--minimap2
else
$(error "Unknown mapper: $(polisher_mapper)")
endif

# Find the complete long read file name
fastq=$(shell test -f $(reads).fq.gz && echo "true")
fastq_uncompressed=$(shell test -f $(reads).fq && echo "true")
ifeq ($(fastq), true)
long_reads=$(reads).fq.gz
endif
ifeq ($(fastq_uncompressed), true)
long_reads=$(reads).fq
endif

# Default parameters GoldRush-Path 
k=22
w=16
tile=1000
u=5
a=5
l=1
o=0.1
x=10
h=3
j=48
s=1011011110110111101101
r=0.9 
M=5
p1=w$(w)_x$(x)
p2=$(p1)_second
P=10
m=5000
# Common parameters for scaffolding and correction tools 
z=1000
t=8

# Default Tigmint parameters
span=2
dist=1000
cut=250

# Default ntLink parameters
k_ntLink=64
w_ntLink=1000

# Default ntJoin parameters
k_ntJoin=24
w_ntJoin=50
no_cut=False
ref_weight=2
rounds=5

# Reference for QUAST run
ref=None
quast_t=48

# Determine path to Gold Rush executables
bin=$(shell dirname `command -v $(MAKEFILE_LIST)`)

# Use pigz or bgzip for parallel compression if available.
ifneq ($(shell command -v pigz),)
gzip=pigz -p$t
else
ifneq ($(shell command -v bgzip),)
gzip=bgzip -@$t
else
gzip=gzip
endif
endif

# Record run time and memory usage in a file using GNU time
track_time=0
ifeq ($(track_time), 0)
time=
else
ifneq ($(shell command -v gtime),)
time=command gtime -v -o $@.time
else
time=command time -v -o $@.time
endif
ifneq ($(shell command -v memusg),)
time=command memusg -t -o $@.time
endif
endif

.PHONY: help run clean path-tigmint-ntlink path-polish goldrush-path racon goldrush-edit path-tigmint tigmint ntLink-with-tigmint path-tigmint-ntJoin ntJoin check-G
.DELETE_ON_ERROR:
.SECONDARY:

# Help
help:
	@echo "GoldRush"
	@echo ""
	@echo "Usage: ./goldrush [COMMAND] [OPTION=VALUE]â€¦"
	@echo ""
	@echo "For example, to run the default pipeline on reads reads.fa.gz and a genome size of gsize:"
	@echo "goldrush run reads=reads G=gsize"
	@echo ""
	@echo "	Commands:"
	@echo ""
	@echo "	run                   run default GoldRush pipeline: GoldRush-Path + Polisher (GoldRush-Edit by default) + Tigmint + ntLink"
	@echo ""
	@echo "	goldrush-path	  	  run GoldRush-Path"
	@echo "	path-polish           run GoldRush-Path, then $(polisher)"
	@echo "	path-tigmint          run GoldRush-Path, then $(polisher), then tigmint"
	@echo "	path-tigmint-ntLink   run GoldRush-Path, then $(polisher), then tigmint, then ntLink (default 5 rounds)"
	@echo "	path-tigmint-ntJoin   run GoldRush-Path, then $(polisher), then tigmint, then ntJoin"
	@echo ""
	@echo "	General options (required):"
	@echo "	reads			read name [reads]. File must have .fq.gz or .fa.gz extension"
	@echo "	G			haploid genome size (bp) (e.g. '3e9' for human genome)"
	@echo ""
	@echo "	General options (optional):"
	@echo "	t			number of threads for scaffolding and correction tools [8]"
	@echo "	z			minimum size of contig (bp) to scaffold [1000]"
	@echo "	track_time		If 1 then track the run time and memory usage, if 0 then don't [0]"
	@echo ""
	@echo "	GoldRush-Path options:"
	@echo "	k		        base k value to generated hash [22]"
	@echo "	w        		weight of spaced seed (number of 1's) [16]"
	@echo "	tile			tile size to use in GoldRush-Path [1000]"	
	@echo "	u			minimum number of unassigned tiles for the read to be considered unassigned [5]"
	@echo "	a			maximum number of tiles that can be assigned, minimum number of overlapping tiles kept after trimming [5]"
	@echo "	l		        number fo golden paths to produce [1]"
	@echo "	o       		occupancy of the miBF [0.1]"
	@echo "	x			threshold for number of hits in miBF for a given frame to be considered assigned [10]"	
	@echo "	h			the number of seed patterns to use [3]"
	@echo "	j			number of threads to use [48]"
	@echo "	s       		spaced seed design [1011011110110111101101]"	
	@echo "	M			maximum number of silver paths to generate [5]"
	@echo "	r			ratio of full genome in golden path [0.9]"
	@echo "	p1			prefix to use for the silver paths [w$(w)_x$(x)]"
	@echo ""
	@echo "	Tigmint options:"
	@echo "	span			min number of spanning molecules to be considered correctly assembled [2]"
	@echo "	dist			maximum distance between alignments to be considered the same molecule [1000]"
	@echo ""
	@echo "	ntLink options:"
	@echo "	k_ntLink		k-mer size for minimizers [64]"
	@echo "	w_ntLink		window size for minimizers [1000]"
	@echo "	rounds			number of rounds of ntLink [5]"
	@echo ""
	@echo "	GoldRush-Edit options:"
	@echo "	polisher_mapper		Whether to use ntlink or minimap2 for mappings [ntlink]"
	@echo ""
	@echo "	ntJoin options:"
	@echo "	k_ntJoin		k-mer size for minimizers [24]"
	@echo "	w_ntJoin		window size for minimizers [50]"
	@echo "	no_cut			If True, will not cut contigs at putative misassemblies [False]"
	@echo "	ref_weight		Weight of the reference assemblies [2]"	
	@echo ""
	@echo "Notes:"
	@echo "	- GoldRush-Path runs the new protocol which generates silver paths before generating the golden path"
	@echo "	- ntJoin runs with the two silver paths instead of the full five"
	@echo "	- Ensure that all input files are in the current working directory, making soft-links if needed"

clean:
	rm -f *.amb *.ann *.bwt *.pac *.sa *.dist.gv *.fai *.bed *.molecule.tsv *.sortbx.bai *.k$(k).w$(w).tsv *.k$(k).w$(w).tsv
	@echo "Clean Done"

# Set-up pipelines 
run: path-tigmint-ntLink check-G
path-polish: $(polisher) check-G
path-tigmint: tigmint check-G
path-tigmint-ntJoin: ntJoin check-G

path-tigmint-ntLink: ntLink_all_rounds ntLink_softlink

check-G:
ifndef G
	$(error G is a required parameter. Run 'goldrush help' for more information)
endif


# Run GoldRush-Path
goldrush-path: $(p2)_golden_path_1.fq check-G

$(p2)_golden_path_1.fq: $(p1)_golden_path_all.fq 
	$(time) goldrush-path  -k $(k) -w $(w) -t $(tile) -u $(u) -a $(a) -l $(l) -o $(o) -p $(p2) -i $(p1)_golden_path_all.fq -h $(h) -j $(j) -P $(P) -x$(x) -s $(s) -m 0 
	echo "Done GoldRush-Path! Golden path can be found in: $@"

$(p1)_golden_path_all.fq: $(p1)_golden_path_$(M).fq
	cat $(p1)_golden_path_*.fq > $(p1)_golden_path_all.fq

$(p1)_golden_path_$(M).fq: $(long_reads)
	$(time) goldrush-path  -k $(k) -w $(w) -t $(tile) -u $(u) -a $(a) -l $(l) -o $(o) -p $(p1) -i $(long_reads)  -h $(h) -j $(j) -x$(x) -P $(P) -s $(s) -T $(G) -r $(r) --new_temp_mode -M $(M) -m $(m)

%.racon-polished.fa: %.fq.$(long_reads).sam %.fq
	$(time) racon -u -t$(t) $(long_reads) $^ > $@
	echo "Done GoldRush-Path + $(polisher)! $(polisher) polished golden path can be found in: $@"

%.goldrush-edit-polished.fa: %.fq $(long_reads)
	$(time) goldrush-edit $(goldrush_edit_opts) -t$(t) $< $(long_reads) $@
	echo "Done GoldRush-Path + $(polisher)! $(polisher) polished golden path can be found in: $@"

# Run racon 
racon: $(p2)_golden_path_1.racon-polished.fa check-G

goldrush-edit: $(p2)_golden_path_1.goldrush-edit-polished.fa check-G

$(p2)_golden_path_1.fq.$(long_reads).sam: $(p2)_golden_path_1.fq $(long_reads)
	$(time) minimap2 -t 48 -a -x map-ont  $< $(long_reads) > $@


# Run tigmint after GoldRush-Path
tigmint: $(p2)_golden_path_1.$(polished_infix).span$(span).dist$(dist).tigmint.fa check-G

$(p2)_golden_path_1.$(polished_infix).span$(span).dist$(dist).tigmint.fa: $(p2)_golden_path_1.$(polished_infix).cut$(cut).tigmint.fa
	ln -sf $< $@
	echo "Done GoldRush-Path + $(polisher) + tigmint! Post-tigmint golden path can be found in: $@"

%.$(polished_infix).cut$(cut).tigmint.fa: %.$(polished_infix).fa $(long_reads)
	$(time) tigmint-make tigmint-long draft=$(p2)_golden_path_1.polished reads=$(reads) cut=$(cut) t=$t G=$G span=$(span) dist=$(dist)



# Run ntJoin after tigmint
ntJoin: $(p2)_golden_path_1.$(polished_infix).span$(span).dist$(dist).tigmint.fa.k$(k_ntJoin).w$(w_ntJoin).n1.all.scaffolds.fa check-G

%.span$(span).dist$(dist).tigmint.fa.k$(k_ntJoin).w$(w_ntJoin).n1.all.scaffolds.fa: %.span$(span).dist$(dist).tigmint.fa ref.config
	$(time) ntJoin assemble target=$< k=$(k_ntJoin) w=$(w_ntJoin) reference_config=ref.config no_cut=$(no_cut)
	echo "Done GoldRush-Path + $(polisher) + tigmint + ntJoin! Post-tigmint golden path can be found in: $@"

ref.config: $(p2)_golden_path_1.fa
	echo "$(p1)_golden_path_1.fa,$(ref_weight)" > ref.config
	echo "$(p1)_golden_path_2.fa,$(ref_weight)" >> ref.config

# Run ntLink rounds after tigmint
ntLink_all_rounds: $(p2)_golden_path_1.$(polished_infix).span$(span).dist$(dist).tigmint.fa.k$(k_ntLink).w$(w_ntLink).z$z.ntLink.gap_fill.$(rounds)rounds.fa check-G


%.fa.k$(k_ntLink).w$(w_ntLink).z$z.ntLink.gap_fill.$(rounds)rounds.fa: %.fa $(long_reads)
	$(time) ntLink_rounds run_rounds_gaps target=$< t=$t k=$(k_ntLink) w=$(w_ntLink) z=$z rounds=$(rounds)

ntLink_softlink: $(p2)_golden_path_1.$(polished_infix).span$(span).dist$(dist).tigmint.fa.k$(k_ntLink).w$(w_ntLink).ntLink-$(rounds)rounds.fa check-G

%.k$(k_ntLink).w$(w_ntLink).ntLink-$(rounds)rounds.fa: %.k$(k_ntLink).w$(w_ntLink).z$z.ntLink.gap_fill.$(rounds)rounds.fa
	ln -sf $(lastword $^) $@
	echo "Done GoldRush-Path + $(polisher) + tigmint + $(rounds) ntLink rounds! Scaffolds can be found in: $@"
